"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ClassModel_1 = require("../ClassModel");
const PropertyModel_1 = require("../PropertyModel");
const MethodModel_1 = require("../MethodModel");
test('new class model initializes correctly', () => {
    const classModel = new ClassModel_1.default();
    expect(classModel.getProperties()).toHaveLength(0);
    expect(classModel.getMethods()).toHaveLength(0);
    expect(classModel.getChildClasses()).toHaveLength(0);
    expect(classModel.getClassName()).toBe('');
    expect(classModel.getTopmostClassName()).toBe('');
    expect(classModel.getClassGroup()).toBe('Miscellaneous');
    expect(classModel.getClassGroupContent()).toBe('');
    expect(classModel.getIsInterface()).toBe(false);
});
test('can set properties', () => {
    const classModel = new ClassModel_1.default();
    const properties = [new PropertyModel_1.default()];
    classModel.setProperties(properties);
    expect(classModel.getProperties()).toBe(properties);
});
test('can set methods', () => {
    const classModel = new ClassModel_1.default();
    const methods = [new MethodModel_1.default()];
    classModel.setMethods(methods);
    expect(classModel.getMethods()).toBe(methods);
});
test('can add children', () => {
    const classModel = new ClassModel_1.default();
    const childClass = new ClassModel_1.default();
    classModel.addChildClass(childClass);
    expect(classModel.getChildClasses().length).toBe(1);
    expect(classModel.getChildClasses()[0]).toBe(childClass);
});
test('class name can be set and retrieved correctly', () => {
    const classModel = new ClassModel_1.default();
    const nameLine = 'public with sharing class TestClassName {';
    classModel.setNameLine(nameLine, 1);
    expect(classModel.getClassName()).toBe('TestClassName');
});
test('interface name can be retrieved correctly', () => {
    const classModel = new ClassModel_1.default();
    const nameLine = 'public interface TestInterfaceName {';
    classModel.setNameLine(nameLine, 1);
    expect(classModel.getClassName()).toBe('TestInterfaceName');
});
test('topmost class name is the class name when it has no parent', () => {
    const classModel = new ClassModel_1.default();
    const nameLine = 'public abstract class TestClassName {';
    classModel.setNameLine(nameLine, 1);
    expect(classModel.getClassName()).toBe('TestClassName');
});
test('topmost class name is parent name', () => {
    const parentClass = new ClassModel_1.default();
    const nameLine = 'public abstract class TestClassName {';
    parentClass.setNameLine(nameLine, 1);
    const childClass = new ClassModel_1.default(parentClass);
    const nameLineChild = 'private class ChildClassName {';
    childClass.setNameLine(nameLineChild, 10);
    expect(childClass.getTopmostClassName()).toBe('TestClassName');
});
test('can add group', () => {
    const classModel = new ClassModel_1.default();
    const groupName = 'GroupName';
    classModel.setClassGroup(groupName);
    expect(classModel.getClassGroup()).toBe(groupName);
});
test('can add group content', () => {
    const classModel = new ClassModel_1.default();
    const groupContentName = 'GroupContentName';
    classModel.setClassGroupContent(groupContentName);
    expect(classModel.getClassGroupContent()).toBe(groupContentName);
});
test('can set as interface', () => {
    const classModel = new ClassModel_1.default();
    classModel.setIsInterface(true);
    expect(classModel.getIsInterface()).toBe(true);
});
